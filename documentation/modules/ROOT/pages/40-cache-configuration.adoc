= Cache Configuration
include::_attributes.adoc[]

Alright, we're all set! Our server is up and running smoothly, with foundational settings neatly configured. It might be tempting to consider this sufficient for a Data Grid administrator. But beneath the surface lies a more intricate narrative.

In the realm of Data Grid, the information takes residence within caches, whose configuration is typically a terrain overseen by development teams. However, the configuration of these caches holds the potential to profoundly influence your infrastructure's performance. That's precisely why it's essential to delve into mastering the cache main settings.


== Caches in Openshift

Multiple mechanisms are available to create caches within a Data Grid cluster deployed on Openshift. You have the option to use traditional methods employed in Data Grid, such as the REST endpoint, Infinispan CLI, or the server configuration file loaded during startup. However, the most effective mechanism when utilizing the operator is the Cache CRD. This Custom Resource offers full configurational flexibility, while the operator constantly monitors changes in cache configuration and promptly synchronizes them with the server.

TIP: Data Grid accommodates cache and server configuration in XML, YAML, and JSON formats. The choice between these formats is a matter of personal preference. However, for the purpose of this workshop, given that we deploy on Openshift, all the examples utilize the YAML format.


Let's create the first cache of the cluster. To do so, you just need to create the Cache CR object with the cache configuration and set the cluster where you want it to be configured. 

.Cache modes
NOTE: Remember that there are two main cache modes: Replicated and Distributed. The main difference is that replicated caches store a copy of each cache key in each node of the cluster, while Distributed caches just store N copies, determined by the `owners` field in the configuration. For the sake of simplicity, we are going to use `replicated-cache` in this workshop, but all cache configurations would be valid for `distributed-cache`.


We are going to use one of the simplest cache configurations: Replicated cache in SYNC mode and statistics enabled.

[.console-input]
[source, yaml]
----
apiVersion: infinispan.org/v2alpha1
kind: Cache
metadata:
  name: cluster-cache-replicated-01
spec:
  clusterName: cluster
  name:  cache-replicated-01
  template: |-
    replicatedCache:
      mode: "SYNC"
      statistics: "true"
  updates:
    strategy: recreate
----

Now, please, access the web console again and check that the cache is configured. Also note that, based on your configuration, the cache is labeled with the most important features. Now, click on the cache name to explore all the information that the server can provide. You will notice that the server complains that you did not define an encoding configuration. Without it, you will lose some great features and you won't be able to store entries in the cache, so let's do it now!







== Encoding

Encoding is the format, identified by a media-type, that Data Grid uses to store entries (key/value pairs) in caches. You will have mainly two options: 

* Protobuf: To optimize speed, ensure interoperability, perform queries on the data, or use the web console to check the cache contents.
* Java Serialization: This option simplifies the configuration of the Java client and server with the disadvantage of losing the benefits of the previous option.


Let's define the encoding format for both the key and the value of all the entries of the cache. By updating the cache definition with the following configuration:

[.console-input]
[source, yaml]
----
apiVersion: infinispan.org/v2alpha1
kind: Cache
metadata:
  name: cluster-cache-replicated-01
spec:
  clusterName: cluster
  name:  cache-replicated-01
  template: |-
    replicatedCache:
      mode: "SYNC"
      statistics: "true"
      encoding:
        key:
          mediaType: application/x-protostream
        value:
          mediaType: application/x-protostream
  updates:
    strategy: recreate
----


Great! Now, you can access the web console again. Navigate to the cache that you just updated and you will see that there is a new tab called `Entries`. 



.View in the web console of the entries of a cache
image::40-cache-rhdg-console-cache-entries.png[]


This tab allows you to explore the cached content and add new entries if you are allowed to. Try it now! If you cannot see the `Add entry` button, make sure that you are logged in as the `admin` user.


.Web form to add entries to a cache
image::40-cache-rhdg-console-cache-new-entry.png[]






== Expiration

Old stuff isn't always useful. We'll show you how to set a timer. The Expiration section instructs Data Grid to remove entries from caches when they reach their time limit regarding expiration or idling.

For this purpose, we will reuse the same cache and modify it to add the new configuration:

[.console-input]
[source, yaml]
----
apiVersion: infinispan.org/v2alpha1
kind: Cache
metadata:
  name: cluster-cache-replicated-01
spec:
  clusterName: cluster
  name:  cache-replicated-01
  template: |-
    replicatedCache:
      mode: "SYNC"
      statistics: "true"
      encoding:
        key:
          mediaType: application/x-protostream
        value:
          mediaType: application/x-protostream
      expiration:
        lifespan: "60000"
        maxIdle: "-1"
  updates:
    strategy: recreate
----


Now, access the web console again and add a second entry. You will notice that new entries will have the configured expiration time, while the old ones are kept forever. There are mechanisms to make sure that all existing entries will expire after the expiration time set in the configuration.


.View entries in the web console with its expiration time
image::40-cache-rhdg-console-cache-expiration.png[]





== Memory

The memory section lets you control the size of the data container by removing entries from memory when a memory or count limit is reached. 

IMPORTANT: As the `spec.updates.strategy` is set to recreate, the operator will remove the cache from the cluster and create it again, so all the entries that you had created will be lost. We can discuss, if you want, the possible reasons and mitigation behind this decision.


[.console-input]
[source, yaml]
----
apiVersion: infinispan.org/v2alpha1
kind: Cache
metadata:
  name: cluster-cache-replicated-01
spec:
  clusterName: cluster
  name:  cache-replicated-01
  template: |-
    replicatedCache:
      mode: "SYNC"
      statistics: "true"
      encoding:
        key:
          mediaType: application/x-protostream
        value:
          mediaType: application/x-protostream
      expiration:
        lifespan: "60000"
        maxIdle: "-1"
      memory:
        maxSize: "200MB"
        whenFull: "REMOVE"
  updates:
    strategy: recreate
----

We are not going to test this limit, but I guess that you trust me :) If not, I recommend you try the `maxCount` limit with an extremely low threshold and add enough entries so that the cluster has to remove some of the existing ones.







== Cache Templates

Templates make life easier. You can set up common settings that caches can borrow or even modify according to specific needs. This is useful if you want to simplify the onboarding of new teams or keep consistency between cache definitions.

The only downside is that, in order to inherit the cache template from a Cache definition, it has to be defined upfront. The simplest way of doing so is to configure templates using the ConfigMap loaded at startup instead of using the `Cache` CRD. How to do it? It is easy, it just needs three steps:

*Step 1: Create a new ConfigMap with the server configuration*

First, we need to create a new ConfigMap that will add server configuration that will be combined with the configuration injected by the operator in the pod. The contents of this file are pretty large, so, for now, we will just need to know that we can add caches in that file.

[.console-input]
[source, yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-custom-config
data:
  infinispan-config.yaml: >
    infinispan:
      cache-container:
        name: "default"
        statistics: "true"
        replicatedCacheConfiguration:
          name: "proto-repl-small-template"
          mode: "SYNC"
          statistics: "true"
          encoding:
            key:
              mediaType: application/x-protostream
            value:
              mediaType: application/x-protostream
          expiration:
            lifespan: "5000"
            maxIdle: "1000"
          memory:
            maxCount: "10"
            whenFull: "REMOVE"
        replicatedCacheConfiguration:
          name: "proto-repl-big-template"
          mode: "SYNC"
          statistics: "true"
          encoding:
            key:
              mediaType: application/x-protostream
            value:
              mediaType: application/x-protostream
          expiration:
            lifespan: "5000"
            maxIdle: "1000"
          memory:
            maxCount: "1000"
            whenFull: "REMOVE"
----

This ConfigMap just defines two cache sizes that developers will then be able to use in their applications. The only difference is that one is limited to 10 entries while the other can hold until 1000.


*Step 2: Configure the Infinispan CR to use the new ConfigMap*

Now, just instruct the Infinispan CR to mount that ConfigMap in the pod and combine the existing server configuration with the new one.

[.console-input]
[source, yaml]
----
apiVersion: infinispan.org/v1
kind: Infinispan
metadata:
  name: cluster
spec:
  configMapName: cluster-custom-config 
----

Wait a few seconds until all the pods restart with the new configuration. Then, log in to the Web Console. In the main dashboard, you will see the `Display cache templates` button. Access that link to see your templates.


*Step 3: Create a new cache using the template*


[.console-input]
[source, yaml]
----
apiVersion: infinispan.org/v2alpha1
kind: Cache
metadata:
  name: cluster-cache-replicated-02
spec:
  clusterName: cluster
  name:  cache-replicated-02
  templateName: proto-repl-small-template
  updates:
    strategy: recreate
----




TIP: Are you interested in inheriting cache configuration but overriding any of its values? You can do it using the same mechanism. Check this https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.4/html-single/configuring_data_grid_caches/index#cache-templates_cache-configuration[link] to the official documentation.



== Wrap Up!

Wrapping up this chapter, we've laid a solid groundwork for navigating Red Hat Data Grid's cache settings. Understanding cache configuration, templates, encoding, expiration, and eviction is key to optimizing your caches. Armed with this knowledge, you're equipped to fine-tune your cache setup, ensuring efficiency and smooth operation. As we move forward, remember that these foundational insights will serve as a springboard to more advanced cache strategies and optimizations.

